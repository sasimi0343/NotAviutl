@[3DEnvironment]
--track0:TextureComp,0,100,0,0.1
--track1:AmbientLight,0,100,0,0.1
--dialog:DontCompOnExport/chk,dontcomponexport=1;Shadows/chk,shadow=0;
--check0:PostProcLights,0
world = {}
world.texcomp = obj.track0
world.dcoe = (dontcomponexport == 1)
world.ppl = obj.check0
world.objs = {}
world.lights = {}
world.surface_all = {}
world.shadow = (shadow == 1)
world.ambient = obj.track1

@[3DRender]
if (not (world == nil)) then

local avi3d = require("avi3d")
require("rikky_module")

for k,v in pairs(world.objs) do
	for _,v2 in pairs(v.geometory) do
		for _,v3 in pairs(v2.surface) do
			table.insert(world.surface_all, v3)
		end
	end
end

for k,v in pairs(world.objs) do
	for _,v2 in pairs(v.geometory) do
		obj.load("figure", "四角形", 0xffffff, 1)
		obj.setoption("antialias", 0)
		rikky_module.image("r", "ms_tex_" .. v.texture)
		obj.ox = v2.ox
		obj.oy = v2.oy
		obj.oz = v2.oz
		obj.rx = v2.rx
		obj.ry = v2.ry
		obj.rz = v2.rz
		rikky_module.image("w", "ms_image_1")
		avi3d.Draw(obj, v2.surface, true, world.lights, v2, world)
		rikky_module.image("r", "ms_image_1")
	end
end


end

@[3DStructure] Check / Save
--file:
--check0:Write

if (world == nil) then return end

local avi3d = require("avi3d")
require("rikky_module")

for k,v in pairs(world.objs) do
	for _,v2 in pairs(v.geometory) do
		for _,v3 in pairs(v2.surface) do
			table.insert(world.surface_all, v3)
		end
	end
end

if (not obj.check0) then
	for k,v in pairs(world.objs) do
		for _,v2 in pairs(v.geometory) do
			obj.load("figure", "四角形", 0xffffff, 1)
			obj.setoption("antialias", 0)
			rikky_module.image("r", "ms_tex_" .. v.texture)
			obj.ox = v2.ox
			obj.oy = v2.oy
			obj.oz = v2.oz
			obj.rx = v2.rx
			obj.ry = v2.ry
			obj.rz = v2.rz
			rikky_module.image("w", "ms_image_1")
			avi3d.Draw(obj, v2.surface, true, nil, v2, world)
			rikky_module.image("r", "ms_image_1")
		end
	end
else
	local kansei = ""
	for k,v in pairs(world.objs) do
		for _,v2 in pairs(v.geometory) do
			kansei = kansei .. "setCurrentGeometory("
			.. v2.ox .. ", " .. v2.oy .. ", " .. v2.oz .. ", "
			.. v2.rx .. ", " .. v2.ry .. ", " .. v2.rz .. ", " .. v2.alpha .. ")\n"
			for _,v3 in pairs(v2.surface) do
				kansei = kansei .. "addSurface("
				.. "Point(" .. v3[1].x .. ", " .. v3[1].y .. ", " .. v3[1].z .. "),"
				.. "Point(" .. v3[2].x .. ", " .. v3[2].y .. ", " .. v3[2].z .. "),"
				.. "Point(" .. v3[3].x .. ", " .. v3[3].y .. ", " .. v3[3].z .. "),"
				.. "Point(" .. v3[4].x .. ", " .. v3[4].y .. ", " .. v3[4].z .. "),"
				.. v3[5] .. ")\n"
			end
			kansei = kansei .. "\n"
		end
	end
	
	if (not (file == "")) then
		io.output(file)
		io.write(kansei)
		io.close()
	end
	
	--print(kansei)
end

@[3DStructure] Load
--track0:Arg1,-9999,9999,0,0.1
--track1:Arg2,-9999,9999,0,0.1
--track2:Arg3,-9999,9999,0,0.1
--track3:Arg4,-9999,9999,0,0.1
--file:
--check0:Reload

if (ms_struct_cache == nil) then
	ms_struct_cache = {}
end

if (ms_struct_cache[file] == nil or obj.check0) then
	
	local fh, err = io.open(file)
	if (not (err == nil)) then
		return
	end
	
	ms_struct_cache[file] = fh:read("*a")
	fh:close()
end

local str = ms_struct_cache[file]

local did = false

local code = load(function()
if (did) then return nil end
did = true
return str
end, "3DStructure")

geos = {}

local function runCode()
	local geo = nil
	function setCurrentGeometory(ox, oy, oz, rx, ry, rz, alpha)
		if (not (geo == nil)) then
			table.insert(geos, geo)
		end
		geo = {
			surface = {},
			shading = {},
			ox = ox,
			oy = oy,
			oz = oz,
			rx = rx,
			ry = ry,
			rz = rz,
			alpha = alpha,
		}
	end
	function Point(x, y, z)
		return {x = x, y = y, z = z}
	end
	function addSurface(p1, p2, p3, p4, brightness)
		table.insert(geo.surface, {p1, p2, p3, p4, brightness})
	end
	
	code()
end

runCode()

obj.load("figure", "四角形", 0xffffff, 1)

@[3D]Arrow_Type2
--track0:サイズ,0,2000,100,1
--track1:太さ,0,100,25,0.1
--track2:へこみ,0,100,80,0.1
--track3:傘,0,100,0,0.1
--dialog:色/col,color=0xffffff;奥行,deep=100;
obj.setoption("drawtarget","tempbuffer", obj.track0, obj.track0)

obj.load("figure", "四角形", color, obj.track0, obj.track0-((obj.track2/100)*obj.track0))
obj.effect("斜めクリッピング", "中心X", -obj.track3, "中心Y", obj.track3, "角度", 45, "ぼかし", 0)
obj.draw()

obj.load("figure", "四角形", color, obj.track0)
obj.effect("斜めクリッピング", "中心X", 0, "中心Y", 0, "角度", -45, "ぼかし", 0, "幅", math.max(1, (obj.track1/100)*obj.track0*1.5))
obj.draw()

obj.setoption("drawtarget","framebuffer")
obj.load("tempbuffer")
obj.draw()

obj.load("tempbuffer")

local avi3d = require("avi3d")


local x1 = obj.track0/2
local y1 = ((obj.track1/100)*obj.track0)
local y2 = -((obj.track1/100)*obj.track0) + (obj.track0/2)

obj.drawpoly(-x, -x, deep, x, -x, deep, x, x, deep, -x, x, deep)

obj.load("figure", "四角形", color, obj.track0)

local p1 = { x = -x1, y = y2, z = 0 }
local p2 = { x = -x1, y = y2, z = deep }
local p3 = { x = y2, y = -x1, z = deep }
local p4 = { x = y2, y = -x1, z = 0 }
local s1 = { p1, p2, p3, p4 }

local p5 = { x = -x1, y = x1, z = deep}
local p6 = { x = -x1, y = x1, z = 0}
local s2 = { p1, p2, p5, p6 }

local p7 = { x = -y2, y = x1, z = 0 }
local p8 = { x = -y2, y = x1, z = deep }
local p9 = { x = x1, y = -y2, z = deep }
local p10 = { x = x1, y = -y2, z = 0 }
local s3 = { p7, p8, p9, p10 }

local s4 = { p7, p8, p5, p6 }

local p11 = { x = (y2 / (2 * (obj.track2/100))), y = -x1 * (1-(obj.track2/100)), z = deep}
local p12 = { x = (y2 / (2 * (obj.track2/100))), y = -x1 * (1-(obj.track2/100)), z = 0}
local s5 = { p3, p4, p11, p12 }

avi3d.Draw(obj, {s1, s2, s3, s4, s5})