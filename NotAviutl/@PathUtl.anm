pathutl = {paths = {}, effects = {}, drawpoint = {}}

@[Path] MakePath
--track0:Precision,1,200,100,0.1
--track1:Connection,0,100,0,0.1
--dialog:Background Color/col,color=nil;[Global]Delay,gdelay=0;[Global]Time,gtime=0;[Global]Global Delay,ggd=0;[ET]Easing,geasing=-1;[ET]BlinkTime,gblinktime=0;[ET]ConnectionStart,gsc=0;[ET]PrecisionStart,gsp=0;

require("rikky_module")
pathutl = {paths = {}, effects = {}, drawpoint = {}}

function pathutl.AddPoint(path1, index, x, y)

table.insert(path1.paths, index, {x = x, y = y})

end

local connection = obj.track1
local precision = obj.track0

if (not (gtime == 0)) then
	if (obj.frame >= gdelay * obj.index + ggd) then
		if (obj.frame < gdelay * obj.index + ggd + gtime) then
			local et = require("et_lib")
			connection = et.easing(geasing, obj, gtime, gdelay, gsc, obj.track1, ggd)
			precision = et.easing(geasing, obj, gtime, gdelay, gsp, obj.track0, ggd)
		else
			if (gblinktime == -1) then
				connection = obj.track1
				precision = obj.track0
			else
				if (gblinktime == 0 or (obj.frame >= gdelay * obj.index + ggd + gtime + gblinktime)) then
					return
				elseif ((obj.frame-(gdelay * obj.index))%2 == 0) then
					return
				end
				connection = obj.track1
				precision = obj.track0
			end
		end
	else
		connection = gsc
		precision = gsp
	end
end

local rpaths, num = rikky_module.linedetection(precision, color, true)

if (connection == 0) then
	for k,v in pairs(rpaths) do
		local upath = {paths = {}, color1 = nil, color2 = nil}
		upath.paths[1] = {x = v.x0, y = v.y0}
		upath.paths[2] = {x = v.x1, y = v.y1}
		
		table.insert(pathutl.paths, upath)
	end
else
	local round = function (num, per)
		return math.floor(num / per) * per
	end
	local round_ceil = function (num, per)
		return math.ceil(num / per) * per
	end
	local almostsame = function (p1, p2, per)
		return (round(p1.x, per) == round(p2.x, per)) and (round(p1.y, per) == round(p2.y, per)) or (round_ceil(p1.x, per) == round(p2.x, per)) and (round_ceil(p1.y, per) == round(p2.y, per))
	end
	
	local function postokey(pos)
		return round(pos.x, connection) .. "_" .. round(pos.y, connection)
	end
	
	local function postokey2(pos)
		return round_ceil(pos.x, connection) .. "_" .. round_ceil(pos.y, connection)
	end
	
	local allpaths = {}
	local allposs = {}
	for k,v in pairs(rpaths) do
		local upath = {paths = {}, color1 = nil, color2 = nil}
		local p1 = {x = v.x0, y = v.y0}
		local p2 = {x = v.x1, y = v.y1}
		local k1, kc1 = postokey(p1), postokey2(p1)
		if (allposs[k1] == nil and allposs[kc1] == nil) then
			upath.paths[1] = p1
			allposs[k1] = p1
		else
			if (not (allposs[kc1] == nil)) then upath.paths[1] = allposs[kc1] else upath.paths[1] = allposs[k1] end
		end
		local k2, kc2 = postokey(p2), postokey2(p2)
		if (allposs[k2] == nil and allposs[kc2] == nil) then
			upath.paths[2] = p2
			allposs[k2] = p2
		else
			if (not (allposs[kc2] == nil)) then upath.paths[2] = allposs[kc2] else upath.paths[2] = allposs[k2] end
		end
		
		table.insert(allpaths, upath)
	end
	
	
	
	local function tostringpos(upath)
		return "(" .. round(upath.paths[1].x, connection) .. "," .. round(upath.paths[1].y, connection) .. ")"
	end
	
	local did = {}
	local didpoints = {}
	local allupaths = {}
	local currentupath = {paths = {}, color1 = nil, color2 = nil}
	local lastpos = nil
	local function check(upath, reversed)
		if (did[upath]) then return end
		if (reversed == nil) then reversed = false end
		did[upath] = true
		local i = 0
		if (reversed) then
			table.sort(upath.paths, function(a, b)
				return true
			end)
		end
		for k,v in pairs(upath.paths) do
			i = i + 1
			--if (didpoints[postokey(v)] == null) then
				table.insert(currentupath.paths, v)
				--didpoints[postokey(v)] = true
			--end
		end
		
		for k,v in pairs(allpaths) do
			if ((not (did[v])) and (almostsame(v.paths[1], upath.paths[#upath.paths], connection) or almostsame(v.paths[#v.paths], upath.paths[#upath.paths], connection) or almostsame(v.paths[1], upath.paths[1], connection) or almostsame(v.paths[#v.paths], upath.paths[1], connection))) then
				--print(">" .. tostringpos(v))
				local isfirst = almostsame(v.paths[1], upath.paths[1], connection) or almostsame(v.paths[#v.paths], upath.paths[1], connection)
				
				local cp = currentupath.paths
				if (isfirst) then currentupath.paths = {} end
				check(v, almostsame(v.paths[#v.paths], upath.paths[#upath.paths], connection) or almostsame(v.paths[1], upath.paths[1], connection))
				if (isfirst) then
					local subp = currentupath.paths
					currentupath.paths = cp
					local i = 0
					for _,v2 in pairs(subp) do
						i = i + 1
						table.insert(currentupath.paths, i, v2)
					end
				end
				--break
			end
		end
		
		lastpos = currentupath.paths[1]
	end
	
	for k,v in pairs(allpaths) do
		if (not (did[v])) then
			--print(tostringpos(v))
			check(v)
			if (not (lastpos == nil)) then
				--table.insert(currentupath.paths, lastpos)
			end
			table.insert(allupaths, currentupath)
			currentupath = {paths = {}, color1 = nil, color2 = nil}
			didpoints = {}
			lastpos = nil
		end
	end
	
	for k,v in pairs(allupaths) do
		table.insert(pathutl.paths, v)
	end
end

@[Path] BeginPath
--track0:X,-9999,9999,0,0.1
--track1:Y,-9999,9999,0,0.1
--check0:AddFirstPath,1

--[[
サルでもわかるPathの構造
	pathutl {
		paths {
			upath {
				paths {x y}
				color1
				color2
			}
		}
		effects {}
		drawpoint {}
	}
]]

pathutl = {paths = {}, effects = {}, drawpoint = {}}
function pathutl.AddPoint(path1, index, x, y)

table.insert(path1.paths, index, {x = x, y = y})

end
local upath = {paths = {}, color1 = nil, color2 = nil}

if (obj.check0) then
upath.paths[1] = {x = obj.track0, y = obj.track1}
table.insert(pathutl.paths, upath)
end

--table.insert(pathutl.paths, upath)

@[Path] AddPaths
--track0:Count,1,16,4,1
--dialog:Pos,pos={};AddPrev/chk,addprev=0;

obj.setanchor("pos", obj.track0, "line")

local upath

if (addprev == 1 and #pathutl.paths > 0) then
	
	upath = pathutl.paths[#pathutl.paths]
	
else
	upath = {paths = {}, color1 = nil, color2 = nil}
	table.insert(pathutl.paths, upath)
end

for i=0,obj.track0-1 do
	local x,y = pos[i*2+1], pos[i*2+2]
	table.insert(upath.paths, {x = x, y = y})
end

@[Path] AddPaths (90deg)
--track0:Count,1,16,4,1
--dialog:Pos,pos={};AddPrev/chk,addprev=0;

obj.setanchor("pos", obj.track0, "line")

local upath

if (addprev == 1 and #pathutl.paths > 0) then
	
	upath = pathutl.paths[#pathutl.paths]
	
else
	upath = {paths = {}, color1 = nil, color2 = nil}
	table.insert(pathutl.paths, upath)
end

for i=0,obj.track0-1 do
	local x,y = pos[i*2+1], pos[i*2+2]
	if (i > 0) then
		local px,py = pos[(i-1)*2+1], pos[(i-1)*2+2]
		local deg = math.deg(math.atan2(py-y, px-x))
		if ((deg >= 45 and deg < 135) or (deg >= -135 and deg < -45)) then
			x = px
			pos[i*2+1] = px
		else
			y = py
			pos[i*2+2] = py
		end
	end
	table.insert(upath.paths, {x = x, y = y})
end

@[Path] AddPaths (Random)
--track0:Count,1,9999,5,1
--track1:Range,0,9999,100,0.1
--track2:Seed,-9999,9999,1,1
--dialog:AddPrev/chk,addprev=0;

local upath

if (addprev == 1 and #pathutl.paths > 0) then
	
	upath = pathutl.paths[#pathutl.paths]
	
else
	upath = {paths = {}, color1 = nil, color2 = nil}
	table.insert(pathutl.paths, upath)
end

for i=0,obj.track0 do
	local rad = math.rad(rand(0, 360, obj.track2, i+1))
	local sin,cos = math.sin(rad), math.cos(rad)
	
	local x,y = cos * obj.track1, sin * obj.track1
	
	table.insert(upath.paths, {x = x, y = y})
end

@[Path] AddSineWave
--track0:Amplitude,0,9999,50,0.1
--track1:Frequency,0,9999,200,0.1
--track2:TimeOffset,-9999,9999,0,0.1
--track3:Width,0,9999,300,1
--dialog:AddPrev/chk,addprev=0;Offset,offset={0,0};

local upath

if (addprev == 1 and #pathutl.paths > 0) then
	
	upath = pathutl.paths[#pathutl.paths]
	
else
	upath = {paths = {}, color1 = nil, color2 = nil}
	table.insert(pathutl.paths, upath)
end

for i=0,obj.track3 do
	local rad = math.rad(((i + obj.track2) / obj.track1) * 360)
	local sin = math.sin(rad)
	
	local x,y = i - (obj.track3 / 2), sin * obj.track0
	
	table.insert(upath.paths, {x = x + offset[1], y = y + offset[2]})
end

@[Path] AddPaths (Relative)
--track0:Count,1,16,4,1
--dialog:Pos,pos={};Rotate/chk,rotate=0;

obj.setanchor("pos", obj.track0, "line")

for l=1,#pathutl.paths do
	
	local upath = pathutl.paths[l]
	local originX, originY = 0, 0
	if (#upath.paths > 0) then
		originX = upath.paths[#upath.paths].x
		originY = upath.paths[#upath.paths].y
	end
	
	for i=0,obj.track0-1 do
		local x,y = pos[i*2+1], pos[i*2+2]
		if (rotate == 1 and #upath.paths > 1) then
			local dist = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
			local rad1 = math.atan2(y, x)
			local rad2 = math.atan2(upath.paths[#upath.paths].y - upath.paths[#upath.paths-1].y, upath.paths[#upath.paths].x - upath.paths[#upath.paths-1].x)
			
			local rad = rad1 + rad2
			y = math.sin(rad) * dist + originY
			x = math.cos(rad) * dist + originX
		else
			x = originX + x
			y = originY + y
		end
		table.insert(upath.paths, {x = x, y = y})
	end
end

@[Path] AddBezierPath (2D)
--track0:X,-9999,9999,100,0.1
--track1:Y,-9999,9999,0,0.1
--track2:x1,-9999,9999,50,0.1
--track3:y1,-9999,9999,50,0.1
--dialog:Perfection%,perf=100;

local upath

if (#pathutl.paths > 0) then
	
	upath = pathutl.paths[#pathutl.paths]
	
else
	upath = {paths = {}, color1 = nil, color2 = nil}
	table.insert(pathutl.paths, upath)
end

local ox,oy = 0,0

if (#upath.paths > 0) then
	ox = upath.paths[#upath.paths].x
	oy = upath.paths[#upath.paths].y
end

local distance = math.sqrt(math.pow(obj.track0 - ox, 2) + math.pow(obj.track1 - oy, 2))
local count = math.floor((perf/100) * distance)

for i=0,count do
	local t = i/count
	local x = ((ox - (obj.track2 * 2) + obj.track0) * math.pow(t, 2)) + (((-2 * ox) + (2 * obj.track2)) * t) + ox
	local y = ((oy - (obj.track3 * 2) + obj.track1) * math.pow(t, 2)) + (((-2 * oy) + (2 * obj.track3)) * t) + oy
	
	table.insert(upath.paths, {x = x, y = y})
end

@[Path] Primitive_LinePattern
--track0:Row,1,9999,5,1
--track1:Offset%,-9999,9999,0,0.1
--track2:Width,0,9999,400,0.1
--track3:LineLength,1,9999,200,0.1
--dialog:Vertical/chk,vertical=0;Reverse/chk,reverse=0;ColumnSpace,columnspace=0;RowSpace,rowspace=50;RowOffset,rowoffset=10;DrawOutofRange/chk,drawoor=0;

for i=1,obj.track0 do
	
	local lwp = obj.track3 + columnspace
	local co = math.ceil(obj.track2/lwp)+1
	local y = ((i-1) - ((obj.track0-1)/2)) * rowspace
	for l=0,co do
		local upath = {paths = {}, color1 = nil, color2 = nil}
		local x1 = (lwp * ((l-math.ceil(co/2)) - (((obj.track1 + (rowoffset * i))%100)/100)))
		local x2 = x1 + obj.track3
		
		if (drawoor == 0) then
			x1 = math.min(math.max(x1, -obj.track2/2), obj.track2/2)
			x2 = math.min(math.max(x2, -obj.track2/2), obj.track2/2)
		end
		
		if (not (x1 - x2 == 0)) then
			if (reverse == 1) then
				local x3 = x1
				x1 = x2
				x2 = x3
			end
			
			if (vertical == 1) then
				table.insert(upath.paths, {x = y, y = x1})
				table.insert(upath.paths, {x = y, y = x2})
			else
				table.insert(upath.paths, {x = x1, y = y})
				table.insert(upath.paths, {x = x2, y = y})
			end
			table.insert(pathutl.paths, upath)
		end
	end
end

@[Path] Colors
--track0:Hue,0,360,5,0.1
--track1:Sat,0,100,10,0.1
--track2:Vue,0,100,10,0.1
--dialog:Base Color/col,color=0xffffff;Seed,seed=1;Color1/chk,setcol1=1;Color2/chk,setcol2=0;

local i = 0
for k,val in pairs(pathutl.paths) do
	local h,s,v = HSV(color)
	h = h + obj.rand(-obj.track0 / 2, obj.track0 / 2, seed, i * 3 + 1)
	if (h >= 360) then
		h = h - 360
	elseif (h < 0) then
		h = h + 360
	end
	
	s = s + obj.rand(-obj.track1 / 2, obj.track1 / 2, seed, i * 3 + 2)
	if (s >= 100) then
		s = 100
	elseif (s <= 0) then
		s = 0
	end
	
	v = v + obj.rand(-obj.track2 / 2, obj.track2 / 2, seed, i * 3 + 3)
	if (v >= 100) then
		v = 100
	elseif (v <= 0) then
		v = 0
	end
	
	local col = HSV(h,s,v)
	
	if (setcol1 == 1) then val.color1 = col end
	if (setcol2 == 1) then val.color2 = col end
	
	i = i + 1
end

@[Path] Colors (Gradient)
--track0:Hue,0,360,5,0.1
--track1:Sat,0,100,10,0.1
--track2:Vue,0,100,10,0.1
--dialog:Base Color/col,color=0xffffff;Base Color2/col,color2=0xffffff;Seed,seed=1;Color1/chk,setcol1=1;Color2/chk,setcol2=0;WholeScale/chk,wholescale=0;

local i = 0
for k,val in pairs(pathutl.paths) do
	local h,s,v = HSV(color)
	local h2,s2,v2 = HSV(color2)
	h = h + obj.rand(-obj.track0 / 2, obj.track0 / 2, seed, i * 6 + 1)
	h2 = h2 + obj.rand(-obj.track0 / 2, obj.track0 / 2, seed, i * 6 + 4)
	if (h >= 360) then
		h = h - 360
	elseif (h < 0) then
		h = h + 360
	end
	if (h2 >= 360) then
		h2 = h2 - 360
	elseif (h2 < 0) then
		h2 = h2 + 360
	end
	
	s = s + obj.rand(-obj.track1 / 2, obj.track1 / 2, seed, i * 6 + 2)
	s2 = s2 + obj.rand(-obj.track1 / 2, obj.track1 / 2, seed, i * 6 + 5)
	if (s >= 100) then
		s = 100
	elseif (s <= 0) then
		s = 0
	end
	if (s2 >= 100) then
		s2 = 100
	elseif (s2 <= 0) then
		s2 = 0
	end
	
	v = v + obj.rand(-obj.track2 / 2, obj.track2 / 2, seed, i * 6 + 3)
	v2 = v2 + obj.rand(-obj.track2 / 2, obj.track2 / 2, seed, i * 6 + 6)
	if (v >= 100) then
		v = 100
	elseif (v <= 0) then
		v = 0
	end
	if (v2 >= 100) then
		v2 = 100
	elseif (v2 <= 0) then
		v2 = 0
	end
	
	local col = HSV(h,s,v)
	local col2 = HSV(h2,s2,v2)
	
	if (setcol1 == 1) then val.color1 = col end
	if (setcol2 == 1) then val.color2 = col end
	
	val.gradient = {gradend = col2, wholescale = (wholescale == 1)}
	
	i = i + 1
end

@[Path] Point Move
--track0:X,-9999,9999,0,0.1
--track1:Y,-9999,9999,0,0.1
--dialog:Selection,selection=nil;

if (selection == nil) then
	selection = pathutl_selection
end

local index = 0
for k,v in pairs(pathutl.paths) do
	for _,v2 in pairs(v.paths) do
		local contains = false
		for _,v3 in pairs(selection) do
			if (index == v3) then
				contains = true
				break
			end
		end
		if (contains) then
			v2.x = v2.x + obj.track0
			v2.y = v2.y + obj.track1
		end
		
		index = index + 1
	end
end

@[Path] Scale
--track0:X,-9999,9999,1,0.1
--track1:Y,-9999,9999,1,0.1
--track2:OriginX,-9999,9999,0,0.1
--track3:OriginY,-9999,9999,0,0.1
--dialog:Selection/chk,selection=0;

local function getCenter(paths)
	local ol,orr,ot,ob = 0,0,0,0
	for k,v in pairs(paths) do
		ol = math.min(v.x, ol)
		orr = math.max(v.x, orr)
		ot = math.min(v.y, ot)
		ob = math.max(v.y, ob)
	end
	return ((ol+orr)/2) + obj.track2,((ot+ob)/2) + obj.track3
end

for k,v in pairs(pathutl.paths) do
	local ox,oy = getCenter(v.paths)
	for _,v2 in pairs(v.paths) do
		local rx,ry = ((v2.x - ox) * obj.track0) + ox, ((v2.y - oy) * obj.track1) + oy
		v2.x = rx
		v2.y = ry
	end
end

@[Path] Rotate
--track0:Angle,-9999,9999,0,0.1
--track1:OriginX,-9999,9999,0,0.1
--track2:OriginY,-9999,9999,0,0.1
--dialog:Selection/chk,selection=0;

local function getCenter(paths)
	local ol,orr,ot,ob = 0,0,0,0
	for k,v in pairs(paths) do
		ol = math.min(v.x, ol)
		orr = math.max(v.x, orr)
		ot = math.min(v.y, ot)
		ob = math.max(v.y, ob)
	end
	return ((ol+orr)/2) + obj.track1,((ot+ob)/2) + obj.track2
end

local rad = math.rad(obj.track0)

for k,v in pairs(pathutl.paths) do
	local ox,oy = getCenter(v.paths)
	for _,v2 in pairs(v.paths) do
		local dx,dy = v2.x - ox, v2.y - oy
		local radius = math.sqrt(math.pow(dx, 2) + math.pow(dy, 2))
		local radA = math.atan2(dy, dx)
		local radd = radA + rad
		
		local rx,ry = math.cos(radd) * radius, math.sin(radd) * radius
		v2.x = rx
		v2.y = ry
	end
end


@[Path] SelectPoints (Index)
--track0:Index,0,9999,0,1
pathutl_selection = {math.floor(obj.track0)}

@[Path] SelectPoints (Range)
--track0:X,-9999,9999,0,0.1
--track1:Y,-9999,9999,0,0.1
--track2:Width,0,9999,100,0.1
--track3:Height,0,9999,100,0.1

function IsRange(pos)
	return (pos.x >= obj.track0 - (obj.track2 / 2) and pos.x <= obj.track0 + (obj.track2 / 2)) and
			(pos.y >= obj.track1 - (obj.track3 / 2) and pos.y <= obj.track1 + (obj.track3 / 2))
end

pathutl_selection = {}
local index = 0
for k,v in pairs(pathutl.paths) do
	for _,v2 in pairs(v.paths) do
		if (IsRange(v2)) then
			table.insert(pathutl_selection, index)
		end
		index = index + 1
	end
end

@[Path] SelectPoints (Edge)

pathutl_selection = {}
local index = 0
for k,v in pairs(pathutl.paths) do
	local i = 0
	for _,v2 in pairs(v.paths) do
		if (i == 0) or (i+1 == #v.paths) then
			table.insert(pathutl_selection, index)
		end
		index = index + 1
		i = i + 1
	end
end


@[Path] Saw
--track0:Rate,0,100,50,0.1
--track1:Depth,-9999,9999,0,0.1
--track2:Depth2,-9999,9999,0,0.1
--check0:

if (#pathutl_selection > 0) then
selection = pathutl_selection
else
selection = pathutl.paths
end

local index = 0
for k,v in pairs(pathutl.paths) do
	local i = 1
	for _,v2 in pairs(v.paths) do
		local contains = false
		for _,v3 in pairs(selection) do
			if (index == v3) then
				contains = true
				break
			end
		end
		local vnext = v.paths[i+1]
		if not (vnext == nil) then
			if (contains) then
				local xadd,yadd = 0, 0
				if (obj.check0) then
					xadd = obj.track1
					yadd = obj.track2
				end
				pathutl.AddPoint(v, i, v2.x + ((vnext.x - v2.x) * (obj.track0/100)) + xadd, v2.y + ((vnext.y - v2.y) * (obj.track0/100)) + yadd)
			end
		end
		
		index = index + 1
		i = i + 1
	end
end

@[Path] PathClip
--track0:Start%,0,100,0,0.1
--track1:End%,0,100,0,0.1

for k,v in pairs(pathutl.paths) do
	local index_start, per_start = math.modf((obj.track0 / 100) * #v.paths)
	local index_end, per_end = math.modf((1 - (obj.track1 / 100)) * #v.paths)
	local i = 0
	local indexes = {}
	for _,v2 in pairs(v.paths) do
		if (index_start > i) then
			table.insert(indexes, i+1)
		elseif (index_end < i) then
			table.insert(indexes, i+1)
		else
			if (index_start == i) then
				local nex = v.paths[i+2]
				if (not (nex == nil)) then
					v2.x = ((nex.x - v2.x) * per_start) + v2.x
					v2.y = ((nex.y - v2.y) * per_start) + v2.y
				end
			end
			if (index_end-1 == i) then
				local nex = v.paths[i+2]
				if (not (nex == nil)) then
					nex.x = ((nex.x - v2.x) * per_end) + v2.x
					nex.y = ((nex.y - v2.y) * per_end) + v2.y
				end
			end
		end
		i = i + 1
	end
	i = 0
	for _,v2 in pairs(indexes) do
		table.remove(v.paths, v2 - i)
		i = i + 1
	end
end

@[Path] ConstantTended
--track0:Length,0,9999,20,0.1
--track1:Count,1,9999,10,1
--track2:Seed,0,9999,1,0.1
--track3:Angle,-9999,9999,0,0.1
--dialog:LengthRange,lenran=0;Tend,tend=30;

local length,count,seed,angle = obj.track0,obj.track1,obj.track2,obj.track3

local i = 0
local theta = math.rad(tend)
for k,v in pairs(pathutl.paths) do
	i = i + 1
	local localseed = seed * i
	local lastpos = v.paths[#v.paths]
	local lastlastpos = v.paths[#v.paths-1]
	if (not ((lastlastpos == nil) or (lastpos == nil))) then
		
		for l=0,count do
			local len = rand(length / 2, length * 2, localseed, l*3)
			local flatlen = rand(length / 2, length * 2, localseed, l*3+1)
			
			local deltaX = lastpos.x - lastlastpos.x
			--local deltaY = lastpos.x - lastlastpos.x
			local deltaY = rand(-1, 1, localseed, l*3+2)
			if (deltaX < 0) then deltaX = -1 else deltaX = 1 end
			if (deltaY < 0) then deltaY = -1 else deltaY = 1 end
			
			local pos1 = {x = lastpos.x + (deltaX * len * math.sin(theta)), y = lastpos.y + (deltaY * len * math.cos(theta))}
			local pos2 = {x = pos1.x + (deltaX * flatlen), y = pos1.y}
			
			table.insert(v.paths, pos1)
			table.insert(v.paths, pos2)
			
			lastlastpos = pos1
			lastpos = pos2
		end
		
	end
end

@[Path] SavePathInfo
--track0:ID,0,9999,0,1
if (pathutl_savedpath == nil) then
	pathutl_savedpath = {}
end

pathutl_savedpath[tostring(obj.track0)] = pathutl.paths

@[Path] LoadPathInfo
--track0:ID,0,9999,0,1
if (pathutl_savedpath == nil or pathutl == nil) then
	return
end

pathutl.paths = pathutl_savedpath[tostring(obj.track0)]

@[Path] MorphPath
--track0:SourceID,0,9999,0,1
--track1:DestID,0,9999,0,1
--track2:Rate,0,100,0,0.1
--track3:Seed,-9999,9999,0,1
--dialog:DisappearProcess,dispr=0;Param1,param1=0;

if (pathutl_savedpath == nil or pathutl == nil) then
	return
end

--[[
削除/出現メソッド
0. 頂点は前の頂点に移動して消える、パスそのものは最初の頂点に集まって消える
1. 頂点は前の頂点に移動して消える、パスそのものは中心に集まって消える
2. 頂点は前の頂点に移動して消える、パスそのものは前の頂点へ圧縮していくように消える
3. 頂点は前の頂点に移動して消える、パスそのものはどこかへ消える
]]

local pathsA = pathutl_savedpath[tostring(obj.track0)]
local pathsB = pathutl_savedpath[tostring(obj.track1)]

local rate = obj.track2/100

if (rate == 0) then
	pathutl.paths = pathsA
	return
elseif (rate == 1) then
	pathutl.paths = pathsB
	return
end

local del_point = 0
local del_path = 0
if (dispr == 1) then del_path = 1 end
if (dispr == 2) then del_path = 2 end
if (dispr == 3) then del_path = 3 end

local count_path = math.max(#pathsA, #pathsB)
local paths = {}

local function getCenter(paths)
	local ol,orr,ot,ob = 0,0,0,0
	for k,v in pairs(paths) do
		ol = math.min(v.x, ol)
		orr = math.max(v.x, orr)
		ot = math.min(v.y, ot)
		ob = math.max(v.y, ob)
	end
	return (ol+orr)/2,(ot+ob)/2
end

local function morphPath(pathA, rate, index)
	local path = {paths = {}, color1 = pathA.color1, color2 = pathA.color2}
	if (del_path == 1) then
		local ox,oy = getCenter(pathA.paths)
		for k,v in pairs(pathA.paths) do
			table.insert(path.paths, {
				x = ((v.x - ox) * rate) + ox,
				y = ((v.y - oy) * rate) + oy,
			})
		end
	elseif (del_path == 2) then
		local first = pathA.paths[1]
		local ox,oy = first.x, first.y
		for k,v in pairs(pathA.paths) do
			if (not (first == v)) then
				local point = {
					x = ((v.x - ox) * rate) + ox,
					y = ((v.y - oy) * rate) + oy,
				}
				table.insert(path.paths, point)
				
				ox,oy = point.x, point.y
			else
				table.insert(path.paths, v)
			end
		end
	elseif (del_path == 3) then
		local first = pathA.paths[1]
		local angle = rand(-360, 360, obj.track3, index)
		local sx,sy = math.cos(math.rad(angle)) * param1 * (1-rate), math.sin(math.rad(angle)) * param1 * (1-rate)
		local ox,oy = first.x + sx, first.y + sy
		for k,v in pairs(pathA.paths) do
			if (not (first == v)) then
				local point = {
					x = ((v.x - ox) * rate) + ox,
					y = ((v.y - oy) * rate) + oy,
				}
				table.insert(path.paths, point)
				
				ox,oy = point.x, point.y
			else
				local point = {
					x = v.x + sx,
					y = v.y + sy,
				}
				table.insert(path.paths, point)
			end
		end
	else
		local first = pathA.paths[1]
		local ox,oy = first.x, first.y
		for k,v in pairs(pathA.paths) do
			table.insert(path.paths, {
				x = ((v.x - ox) * rate) + ox,
				y = ((v.y - oy) * rate) + oy,
			})
		end
	end
	return path
end

for i=1,count_path do
	local pathA = pathsA[i]
	local pathB = pathsB[i]
	if (pathA == nil and pathB == nil) then
	elseif (pathA == nil) then
		table.insert(paths, morphPath(pathB, rate, i))
	elseif (pathB == nil) then
		table.insert(paths, morphPath(pathA, 1-rate, i))
	else
		local path = {paths = {}, color1 = pathB.color1, color2 = pathB.color2}
		local count_point = math.max(#pathA.paths, #pathB.paths)
		local prev = nil
		for l=1,count_point do
			local pA = pathA.paths[l]
			local pB = pathB.paths[l]
			local point = {x = 0, y = 0}
			if (pA == nil and pB == nil) then
			elseif (pA == nil) then
				point.x = (pB.x - prev.x) * rate + prev.x
				point.y = (pB.y - prev.y) * rate + prev.y
			elseif (pB == nil) then
				point.x = (prev.x - pA.x) * rate + pA.x
				point.y = (prev.y - pA.y) * rate + pA.y
			else
				point.x = (pB.x - pA.x) * rate + pA.x
				point.y = (pB.y - pA.y) * rate + pA.y
			end
			
			prev = point
			table.insert(path.paths, point)
		end
		table.insert(paths, path)
	end
end

pathutl.paths = paths

@[Path] ObjectTracker
--track0:TargetID,0,9999,0,1
--track1:X,-9999,9999,0,0.1
--track2:Y,-9999,9999,0,0.1

if (pathutl_savedpath == nil) then
	pathutl_savedpath = {}
end

local upath = {paths = {{x = obj.track1 + obj.ox - obj.cx + obj.getvalue("x"), y = obj.track2 + obj.oy - obj.cy + obj.getvalue("y")}}, color1 = nil, color2 = nil}
pathutl_savedpath[tostring(obj.track0)] = {upath}

@[Path] TrackObjects
--track0:ID,0,9999,0,1
--track1:Index,0,9999,1,1
--track2:Space,-100,9999,100,0.1
--track3:Position,0,100,0,0.1
--dialog:ConstantRotation/chk,constrot=0;CalculateMethod,method=0;Width,linewidth=30;InterpolateRotation,introt=0;

if (pathutl_savedpath == nil) then return end
local pa = pathutl_savedpath[tostring(obj.track0)]
if (pa == nil) then return end
if (pa[obj.track1+1] == nil) then return end
local pat = pa[obj.track1+1]
local rate = ((math.max(obj.track3 - (obj.track2 * obj.index), 0)) / 100)

	local index_start, per_start = math.modf(rate * (#pat.paths-1))
	local i = 0
	local ox,oy = 0,0
	local tan = 0
	for _,v2 in pairs(pat.paths) do
		if (index_start == i) then
			local nex = pat.paths[i+2]
			if (not (nex == nil)) then
				if (method > 0) then
					local t = math.atan2(nex.y - v2.y, nex.x - v2.x)
					local sin,cos = math.sin(t),math.cos(t)
					ox = ((nex.x - v2.x + (cos * linewidth)) * per_start) + v2.x
					oy = ((nex.y - v2.y + (sin * linewidth)) * per_start) + v2.y
				else
					ox = ((nex.x - v2.x) * per_start) + v2.x
					oy = ((nex.y - v2.y) * per_start) + v2.y
				end
				if (constrot == 0) then
					tan = math.deg(math.atan2(nex.y - v2.y, nex.x - v2.x))
					if (introt > 0) then
						if (per_start > (1-(introt / 100)) and (not (pat.paths[i+3] == nil))) then
							local paa = (per_start - (1-(introt / 100))) / (introt / 100)
							local nexttan = math.deg(math.atan2(pat.paths[i+3].y - nex.y, pat.paths[i+3].x - nex.x))
							if (tan > 90 and nexttan < -90) then
								nexttan = nexttan + 360
							elseif (tan < -90 and nexttan > 90) then
								nexttan = nexttan - 360
							end
							tan = ((nexttan - tan) * paa / 2) + tan
						elseif (per_start < (introt / 100) and (not (pat.paths[i] == nil))) then
							local paa = ((introt / 100) - per_start) / (introt / 100)
							local prevtan = math.deg(math.atan2(v2.y - pat.paths[i].y, v2.x - pat.paths[i].x))
							if (tan > 90 and prevtan < -90) then
								prevtan = prevtan + 360
							elseif (tan < -90 and prevtan > 90) then
								prevtan = prevtan - 360
							end
							tan = ((prevtan - tan) * paa / 2) + tan
						end
					end
				end
			else
				ox = v2.x
				oy = v2.y
			end
			break
		end
		i = i + 1
	end
	
obj.ox = ox
obj.oy = oy
if (constrot == 0) then obj.rz = obj.rz + tan end

@[Pen->Path]
--track0:Speed,0,9999,0,0.1
--file:

require("rikky_module")

if (penpath_prevfile == nil) then penpath_prevfile = {} end

if ((drawdata == nil or (not (penpath_prevfile[file] == nil))) and (not (file == ""))) then
	local fh = io.open(file)
	if (not (fh == nil)) then
		local str = fh:read("*a")
		fh:close()
		
		local itizi = rikky_module.string2table(str)
		local data2 = {}
		for i=0,math.floor(#itizi/3) do
			table.insert(data2, {itizi[i*3+1], itizi[i*3+2], itizi[i*3+3]})
		end
		drawdata = data2
		penpath_prevfile[file] = drawdata
	end
end

if (not (drawdata == nil)) then
	if (obj.track0 == 0) then
		local pat = {paths = {}, color1 = nil, color2 = nil}
		for k,v in pairs(drawdata) do
			if (v[1] == nil) then
				
			else
				table.insert(pat.paths, {x = v[1], y = v[2]})
			end
		end
		table.insert(pathutl.paths, pat)
	end
end

@[NewPen->Path]
--track0:Speed,0,9999,0,0.1
--file:

require("rikky_module")

if (penpath_prevfile == nil) then penpath_prevfile = {} end

if ((drawdata == nil and (penpath_prevfile[file] == nil)) and (not (file == ""))) then
	local fh = io.open(file)
	if (not (fh == nil)) then
		local str = fh:read("*a")
		fh:close()
		
		local itizi = rikky_module.string2table(str)
		local data2 = {}
		for i=0,math.floor(#itizi/4) do
			table.insert(data2, {itizi[i*4+1], itizi[i*4+2], itizi[i*4+3], itizi[i*4+4]})
		end
		drawdata = data2
		penpath_prevfile[file] = drawdata
	end
end

if ((drawdata == nil) and (not (penpath_prevfile[file] == nil))) then
	drawdata = penpath_prevfile[file]
end

if (not (drawdata == nil)) then
	if (obj.track0 == 0) then
		local pat = nil
		local newline = true
		for k,v in pairs(drawdata) do
			if (newline) then
				pat = {paths = {}, color1 = nil, color2 = nil}
				table.insert(pathutl.paths, pat)
				newline = false
			end
			if (v[1] == nil) then
				
			else
				table.insert(pat.paths, {x = v[1], y = v[2]})
				if (not v[4]) then
					newline = true
				end
			end
		end
		--table.insert(pathutl.paths, pat)
	end
end

drawdata = nil

@[Path] DrawPoints
--track0:Size,0,9999,10,1
--track1:Border,0,9999,4000,1
--track2:Alpha,0,100,100,0.1
--dialog:Selection,selection=nil;Figure/fig,figure=nil;Color/col,color=0xffffff;

table.insert(pathutl.drawpoint, {
	size = obj.track0,
	border = obj.track1,
	figure = figure,
	color = color,
	alpha = obj.track2
})

@[Path] ClosePath

if (#pathutl.paths == 0) then
	return
end

for k,v in pairs(pathutl.paths) do
	table.insert(v.paths, v.paths[1])
end

@[Path] DrawPath
--track0:Border,0,9999,3,0.1
--dialog:Color Override/col,color=nil;Figure/fig,figure=nil;PolyAlpha,polyalpha=0.0;BorderDrawMethod,bdm=0;

if (#pathutl.paths == 0) then
	return
end

require("rikky_module")

local ox,oy,oz,rx,ry,rz,zoom,alpha,aspect,cx,cy,cz = obj.ox, obj.oy, obj.oz, obj.rx, obj.ry, obj.rz, obj.zoom, obj.alpha, obj.aspect, obj.cx, obj.cy, obj.cz

local b = obj.track0

if (bdm == nil) then
	bdm = 0
end

if (not (figure == nil)) then
	obj.load("figure", figure, 0xffffff, 1)
end

rikky_module.image("w", "na_path_original")

if (not (color == nil or color == "")) then
	obj.effect("単色化", "color", color, "輝度を保持する", 0)
end

local maxx,maxy,minx,miny = 0,0,0,0

for k,v in pairs(pathutl.paths) do
	for _,v2 in pairs(v.paths) do
		maxx = math.max(maxx, v2.x)
		maxy = math.max(maxy, v2.y)
		minx = math.min(minx, v2.x)
		miny = math.min(miny, v2.y)
	end
end

obj.setoption("drawtarget", "tempbuffer", (math.max(math.abs(minx), maxx) + b) * 2, (math.max(math.abs(miny), maxy) + b) * 2)

if (polyalpha > 0) then
for k,v in pairs(pathutl.paths) do
	local i = 1
	obj.setoption("antialias", 0)
	rikky_module.image("r", "na_path_original")
	if (not (v.color2 == nil)) then
		obj.effect("単色化", "color", v.color2, "輝度を保持する", 0)
	end
	local dx,dy = 0, 0
	local sumA,sumB = 0,0
	i = 1
	local prevDeg = 0
	for _,v2 in pairs(v.paths) do
		dx = dx + v2.x
		dy = dy + v2.y
		
		if (i-2 > 0) then
			local prev1 = v.paths[i-1]
			local prev2 = v.paths[i-2]
			local tan1 = math.deg(math.atan2(prev1.y-prev2.y, prev1.x-prev2.x))
			local tan2 = math.deg(math.atan2(v2.y-prev1.y, v2.x-prev1.x))
			local deg = 180 - math.abs(tan2 - tan1)
			
			sumA = sumA + deg
			sumB = sumB + (360 - deg)
		end
		i = i + 1
	end
	local invert = sumA > sumB
	dx = dx / #v.paths
	dy = dy / #v.paths
	i = 1
	local soppo = {}
	local flips = {}
	local flipped = false
	local anglesums = {}
	local degs = {}
	for _,v2 in pairs(v.paths) do
		if (i-2 > 0) then
			local prev1 = v.paths[i-1]
			local prev2 = v.paths[i-2]
			local tan1 = math.deg(math.atan2(prev1.y-prev2.y, prev1.x-prev2.x))
			local tan2 = math.deg(math.atan2(v2.y-prev1.y, v2.x-prev1.x))
			local deg = 180 - math.abs(tan2 - tan1)
			
			--if (math.abs(tan2) >= 90) then
				--flipped = not flipped
			--end
			if (i-3 > 0) then
				local first = v.paths[1]
				local second = v.paths[2]
				local tan3 = math.deg(math.atan2(first.y-v2.y, first.x-v2.x))
				local degfirst = 180 - math.abs(tan3 - tan2)
				local tan4 = math.deg(math.atan2(second.y-first.y, second.x-first.x))
				local degsecond = 180 - math.abs(tan4 - tan3)
				--頂点を一つ増やすと変わるのはdegfirst、deg、degsecond
				--この中の誰かが嘘をついていた場合...
				
				local sum1 = (anglesums[i-1] + math.abs(degfirst) + math.abs(deg) + math.abs(degsecond))
				local sum2 = (anglesums[i-1] + (360 - math.abs(degfirst)) + math.abs(deg) + math.abs(degsecond))
				local sum3 = (anglesums[i-1] + math.abs(degfirst) + math.abs(deg) + (360 - math.abs(degsecond)))
				local sum4 = (anglesums[i-1] + math.abs(degfirst) + (360 - math.abs(deg)) + math.abs(degsecond))
				local sumP = (i-2) * 180
				--print("" .. tostring(i-1) .. ", (" .. tostring(sum4 - sumP) .. ", " .. tostring(sum1 - sumP) .. ")")
				--if (sum1 == sumP) then
				--elseif (sum2 == sumP) then
				--elseif (sum3 == sumP) then
				--elseif (sum4 == (i-2) * 180) then
				local d1,d2,d3,d4 = math.abs(sum1 - sumP),math.abs(sum2 - sumP),math.abs(sum3 - sumP),math.abs(sum4 - sumP)
				
				if (d4 < d1 and d4 < d3 and d4 < d2) then
					deg = 360 - math.abs(deg)
					--print("betrayed: " .. tostring(i) .. ", (" .. tostring(sum4 - sumP) .. ", " .. tostring(sum1 - sumP) .. ")")
				end
				anglesums[i] = anglesums[i-1] + math.abs(deg)
			else
				anglesums[i] = math.abs(deg)
			end
			
			if (v2.x == prev1.x) then
				soppo[i] = ((dx < v2.x) and (flipped)) or ((dx > v2.x) and (not flipped))
				if (i > 2) then soppo[i] = soppo[i-1] end
			else
				flipped = math.abs(tan2) >= 90
				local tanA = (v2.y-prev1.y)/(v2.x-prev1.x) -- y - prev1.y = tan1 * (x - prev1.x)
				
				soppo[i] = ((dy > (tanA * (dx - prev1.x)) + prev1.y) and (flipped)) or ((dy < (tanA * (dx - prev1.x)) + prev1.y) and (not flipped))
			end
			
			flips[i] = flipped
			degs[i] = deg
			obj.drawpoly(dx, dy, 0, prev1.x, prev1.y, 0, v2.x, v2.y, 0, v2.x, v2.y, 0, 0,0, obj.w,0, obj.w,obj.h, 0,obj.h, polyalpha)
		elseif (i-1 > 0) then
			local prev1 = v.paths[i-1]
			obj.drawpoly(dx, dy, 0, prev1.x, prev1.y, 0, v2.x, v2.y, 0, v2.x, v2.y, 0, 0,0, obj.w,0, obj.w,obj.h, 0,obj.h, polyalpha)
		end
		i = i + 1
	end
	i = 1
	local soppostreak_point = nil
	for _,v2 in pairs(v.paths) do
		if (i-2 > 0) then
			local prev1 = v.paths[i-1]
			local prev2 = v.paths[i-2]
			
			local p1,p2,p3,p4 = false,false,false,false
			
			local tan1 = math.deg(math.atan2(prev1.y-prev2.y, prev1.x-prev2.x))
			local tan2 = math.deg(math.atan2(v2.y-prev1.y, v2.x-prev1.x))
			local deg = degs[i]
			local degnext = 0
			
			if (i+1 <= #v.paths) then
				local nex = v.paths[i+1]
				local tan0 = math.deg(math.atan2(nex.y-v2.y, nex.x-v2.x))
				degnext = degs[i+1]
				
				p2 = (deg > 180) or (degnext > 180)
				p3 = (degnext > 180)
			else
				p2 = false
			end
			
			p1 = soppo[i]
			
			if ((soppostreak_point == nil) and (degnext > 180)) then
				soppostreak_point = prev1
			end
			
			if (not (soppostreak_point == nil)) then
				obj.setoption("blend", "alpha_sub")
				obj.drawpoly(soppostreak_point.x, soppostreak_point.y, 0, prev1.x, prev1.y, 0, v2.x, v2.y, 0, v2.x, v2.y, 0, 0,0, obj.w,0, obj.w,obj.h, 0,obj.h, polyalpha)
				obj.setoption("blend", 0)
				if (not p3) then
					soppostreak_point = nil
				end
			elseif ((not p1) and p2) then
				obj.drawpoly(prev2.x, prev2.y, 0, prev1.x, prev1.y, 0, v2.x, v2.y, 0, v2.x, v2.y, 0, 0,0, obj.w,0, obj.w,obj.h, 0,obj.h, polyalpha)
			elseif (p1 and (not p2)) then
				obj.setoption("blend", "alpha_sub")
				obj.drawpoly(dx, dy, 0, prev1.x, prev1.y, 0, v2.x, v2.y, 0, v2.x, v2.y, 0, 0,0, obj.w,0, obj.w,obj.h, 0,obj.h, polyalpha)
				obj.setoption("blend", 0)
			else
				--obj.drawpoly(dx, dy, 0, prev1.x, prev1.y, 0, v2.x, v2.y, 0, v2.x, v2.y, 0, 0,0, obj.w,0, obj.w,obj.h, 0,obj.h, polyalpha)
			end
			
			--[[obj.setfont("MS UI Gothic", 50, 0, 0xff0000)
			obj.load("text", tostring(math.floor(deg)))
			--obj.draw((v2.x + prev1.x)/2, (v2.y + prev1.y)/2)
			obj.draw((prev1.x)+30, (prev1.y))
			rikky_module.image("r", "na_path_original")]]
		end
		i = i + 1
	end
	
	--[[obj.setoption("blend", "alpha_sub")
	local i = 1
	for _,v2 in pairs(v.paths) do
		if (i-2 > 0) then
			local prev1 = v.paths[i-1]
			local prev2 = v.paths[i-2]
			
			local tan1 = math.abs(math.deg(math.atan2(prev1.y-prev2.y, prev1.x-prev2.x)))
			local tan2 = math.abs(math.deg(math.atan2(prev1.y-v2.y, prev1.x-v2.x)))
			
			if (tan1 + tan2 > 180) then
				obj.drawpoly(prev2.x, prev2.y, 0, prev1.x, prev1.y, 0, v2.x, v2.y, 0, v2.x, v2.y, 0, 0,0, obj.w,0, obj.w,obj.h, 0,obj.h, polyalpha)
				print("tan1: " .. tan1 .. ", tan2: " .. tan2 .. "←")
			else
				print("tan1: " .. tan1 .. ", tan2: " .. tan2)
			end
		end
		i = i + 1
	end]]
	obj.setoption("blend", 0)
	obj.setoption("antialias", 1)
end
end

for k,v in pairs(pathutl.paths) do
	local i = 1
	local prevpos = nil
	rikky_module.image("r", "na_path_original")
	if (not (v.color1 == nil)) then
		obj.effect("単色化", "color", v.color1, "輝度を保持する", 0)
	end
	--print(#v.paths)
	for _,v2 in pairs(v.paths) do
		if (i-1 > 0) then
			local prev = v.paths[i-1]
			
			local theta1 = math.atan2(v2.y-prev.y, v2.x-prev.x) + math.rad(135)
			local theta2 = theta1 - (math.rad(135) * 2)
			local theta3 = math.atan2(prev.y-v2.y, prev.x-v2.x) + math.rad(135)
			local theta4 = theta3 - (math.rad(135) * 2)
			local sin1, cos1, sin2, cos2 = 0, 0, 0, 0
			local sin3, cos3, sin4, cos4 = 0, 0, 0, 0
			sin1, cos1 = math.sin(theta1), math.cos(theta1)
			sin2, cos2 = math.sin(theta2), math.cos(theta2)
			sin3, cos3 = math.sin(theta3), math.cos(theta3)
			sin4, cos4 = math.sin(theta4), math.cos(theta4)
			
			if (not (v.gradient == nil)) then
				local length = math.sqrt(math.pow((v2.x - prev.x), 2) + math.pow((v2.y - prev.y), 2))
				obj.effect("リサイズ", "X", math.max(length, 1), "Y", obj.track0, "ドット数でサイズ指定", 1)
				if (v.gradient.wholescale) then
					local h1,s1,v1 = HSV(v.color1)
					local h2,s2,v2 = HSV(v.gradient.gradend)
					local h3,s3,v3 = h1 + (((h2 - h1) / #v.paths) * (i-1)),s1 + (((s2 - s1) / #v.paths) * (i-1)),v1 + (((v2 - v1) / #v.paths) * (i-1))
					local h4,s4,v4 = h1 + (((h2 - h1) / #v.paths) * i),s1 + (((s2 - s1) / #v.paths) * i),v1 + (((v2 - v1) / #v.paths) * i)
					
					local col1,col2 = HSV(h3, s3, v3),HSV(h4, s4, v4)
					
					if (obj.w == 1) then
						obj.effect("単色化", "color", col1, "輝度を保持する", 0)
					else
						obj.effect("グラデーション", "角度", -90, "幅", length, "color", col1, "color2", col2)
					end
				else
					obj.effect("グラデーション", "角度", -90, "幅", length, "color", v.color1, "color2", v.gradient.gradend)
				end
			end
			
			if ((bdm == 1) and (not (prevpos == nil))) then
				sin1, cos1, sin2, cos2 = prevpos.sin3, prevpos.cos3, prevpos.sin4, prevpos.cos4
				obj.drawpoly(prev.x+(b * cos1), prev.y+(b * sin1), 0, v2.x+(b * cos4), v2.y+(b * sin4), 0, v2.x+(b * cos3), v2.y+(b * sin3), 0, prev.x+(b * cos2), prev.y+(b * sin2), 0)
			end
			
			obj.drawpoly(prev.x+(b * cos1), prev.y+(b * sin1), 0, v2.x+(b * cos4), v2.y+(b * sin4), 0, v2.x+(b * cos3), v2.y+(b * sin3), 0, prev.x+(b * cos2), prev.y+(b * sin2), 0)
			
			if (bdm == 1) then prevpos = {sin3 = sin3, cos3 = cos3, sin4 = sin4, cos4 = cos4} end
		end
		i = i + 1
	end
end

for _,points in pairs(pathutl.drawpoint) do
	for k,v in pairs(pathutl.paths) do
		local i = 1
		
		if (points.figure == "text") then
			obj.setfont("MS UI Gothic", points.size, 0, points.color)
			obj.load("text", i)
		else
			obj.load("figure", points.figure, points.color, points.size, points.border)
		end
		local prevposs = {}
		for _,v2 in pairs(v.paths) do
			if (not (i-1 == prevposs[v2])) then
				
				if (points.figure == "text") then
					obj.setfont("MS UI Gothic", points.size, 0, points.color)
					obj.load("text", i)
				end
				prevposs[v2] = i
				obj.draw(v2.x, v2.y, 0, 1.0, points.alpha / 100)
				i = i + 1
				
			end
		end
	end
end

for _,func in pairs(pathutl.effects) do
	local index = 0
	for k,v in pairs(pathutl.paths) do
		for _,v2 in pairs(v.paths) do
			func(index, v2, v)
			index = index + 1
		end
	end
end

obj.setoption("drawtarget", "framebuffer")
obj.load("tempbuffer")

obj.ox, obj.oy, obj.oz, obj.rx, obj.ry, obj.rz, obj.zoom, obj.alpha, obj.aspect, obj.cx, obj.cy, obj.cz = ox,oy,oz,rx,ry,rz,zoom,alpha,aspect,cx,cy,cz